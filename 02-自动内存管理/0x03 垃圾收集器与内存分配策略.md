# 第3章 垃圾收集器与内存分配策略

垃圾回收主要解决以下三个问题：

1. 哪些内存需要回收？
2. 什么时候回收
3. 如何回收？

## 判断对象是否存活

在堆里面存放着Java世界中几乎所有的对象实例， 垃圾收集器在对堆进行回收前， 第一件事情就是要确定这些对象之中哪些还“存活”着， 哪些已经“死去”了。

### 引用计数算法

**算法流程**：

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器值减一；任何时刻计数器为0的对象就是不可能再被使用的。

**缺点**：

难以解决循环引用问题。即 `objA.instance = objB; objB.instance = objA;`，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。

### 可达性分析算法

**基本思路**：

通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。 

![20200717144013.png](https://github.com/yxcoder1997/PictureBed/blob/master/img/20200717144013.png?raw=true)

对象object 5、 object 6、 object 7虽然互有关联， 但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。 

**在Java中，可作为“GC Roots”的对象为：**

- Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中JNI（即通常所说的Native方法）引用的对象
- 方法区中常量引用的对象
- 方法区中类静态属性引用的对象
- Java虚拟机内部的引用
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等 

GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。

## 四种引用类型

在JDK 1.2版之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strongly Re-ference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强
度依次逐渐减弱。

- **强引用：** 是指在程序中最普遍的引用赋值，即`Object obj=new Object()` 。无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。 
- **软引用：**用来描述一些还有用， 但非必须的对象 。只被软引用关联着的对象， **在系统将要发生内存溢出异常前**， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在JDK 1.2版之后提供了`SoftReference`类来实现软引用。 
- **弱引用：**也是用来描述那些非必须对象， 但是**它的强度比软引用更弱一些**， **被弱引用关联的对象只能生存到下一次垃圾收集发生为止**。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了`WeakReference`类来实现弱引用。 
- **虚引用：**虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 **一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例**。 **为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。** 在JDK 1.2版之后提供了`PhantomReference`类来实现虚引用。 

## 回收堆中无效对象



## 回收方法区