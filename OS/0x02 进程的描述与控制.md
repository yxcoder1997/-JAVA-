# 进程的描述与控制

## 前趋图与程序执行

### 前趋图

前趋图是一个 **有向无循环图** ，用于描述程序执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，结点间的有向边表示俩个结点间的偏序或前趋关系。

### 程序顺序执行

- **程序的顺序执行**

  在执行时某种先后次序顺序执行，并且当前一个程序执行完后，才会运行下一个程序

- **特征**

  - **顺序性：** 程序只能顺序执行
  - **封闭性：** 程序在封闭的环境中运行，即程序运行时独占全机资源
  - **可再现性：** 只要程序执行的环境不变，当程序重复执行时，不论它停顿还是不停顿，结果都相同

### 程序并发执行

- 只要程序之间不存在前趋关系，那么程序就可以并发执行
- **特征**
  - **间断性**
  - **失去封闭性**
  - **不可再现性**

## 进程的描述

### 进程的定义

在多道程序环境下，程序的执行属于并发执行，此时就会有间断性，失去封闭性和不可再现性，所以这就决定了通常的程序是不能参加并发执行的，为了能让程序并发执行，引入了进程的概念。

#### 进程控制块

:star: 为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之配置一个专门的**数据结构** ， 称为**进程控制块（PCB）** ，系统利用PCB描述进程的基本情况和活动过程。

- **进程实体**，它包含以下内容
  - 程序段
  - 相关数据段
  - PCB

一般情况下，把进程实体就简称为进程。

:star:**创建进程，实质上就是创建进程实体中的PCB**

:star:**撤销进程，实质上就是撤销进程实体中的PCB**

#### 进程定义

进程在不同角度有不同定义，常见的定义有如下：

- 进程是程序的一次执行
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

:star2:**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的特征

- **动态性**
  - 进程的实质是进程实体的执行过程
  - 进程”*由创建而产生，由调度而执行，由撤销而消亡*“，可见进程是有一定的生命周期，而程序只是一组有序指令集合
- **并发性**
  - 多个进程实体同存于内存中，并且在一段时间内同时运行，没有建立PCB的程序是不能参与并发执行的。
- **独立性**
  - 进程实体是一个能独立运行，独立获得资源，独立接受调度的基本单位。
- **异步性**
  - 进程是按照异步方式运行的

### 进程的三种基本状态

- **就绪状态**
  - 这是指进程已处于准备好运行的状态，即进程已经分配到除CPU以外的所有资源，只要获得CPU，就可以立即执行
  - 如果系统中有许多处于就绪状态的进行，通常将它们按照一定的策略排成一个队列，称该队列为就绪队列
- **执行状态**
  - 这是指进程已经获得了CPU资源，程序正在执行
    - 单处理机：只有一个进程处于执行状态
    - 多处理机：多个进程处于执行装状态
- **阻塞状态**
  - 这是指正在执行的进程由于发生某种事件(如I/O请求，申请缓冲区失败)暂时无法继续执行的状态
  - 通常会有阻塞队列

### 三种基本状态的转换

![20200718164241.png](https://github.com/yxcoder1997/PictureBed/blob/master/img/20200718164241.png?raw=true)

### 创建状态和终止状态

为了满足PCB对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中为又为进程引入了两种常见的状态：创建状态和终止状态

- **创建状态**

  - 创建进程步骤
    - 由进程申请一个空白PCB 
    - 向PCB中填写用于控制和管理进程的信息
    - 分配该进程运行时所必须的资源
    - 把该进程转入就绪状态并插入就绪队列

  如果**进程所需要的资源尚不能满足，此时的创建工作尚未完成，进程不能被调度运行**，于是把此时进程所处的状态称为创建状态。

  - **目的**：保证进程的调度必须在创建工作完成后进行，以确保对PCB操作的完整性

- **终止状态**

  - 终止进程步骤
    - 等待操作系统进行善后处理
    - 将其PCB清零
    - 将PCB空间返还系统

  当一个进程达到了自然结束点，或时出现了无法克服的错误，或被OS所终结，或被其他由终止权的进程所终结，它将进入终止状态。

  进入终止状态的进程不能再执行，但OS中依然保留一个记录（状态码和计时统计数据），供其他进程收集，收集完毕后将终止该进程。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200718165331.png)

### 挂起操作和进程状态的转换

为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作，即挂起操作。与挂起操作对应的操作是激活操作。

- **挂起操作的引入**
  - 终端用户的需要：用户发现程序运行期间出现问题，希望暂停程序的运行。
  - 父进程亲求：父进程希望挂起自己的某个子进程
  - 负荷调节的需要：当系统的负荷较重时，可由系统把一些不重要的进程挂起，保证系统能正常运行
  - OS的需要：OS有时想挂起某些进程，以便检查运行中的资源使用情况或进行记账
- **引入原语**
  - 挂起原语 `Suspend`
  - 激活原语 `Active`

- **四种状态**

  - 活动就绪状态： 进程处于未被挂起的就绪状态，表示为 `Readya` , 此时进程可以接受调度
  - 静止就绪状态： 当用挂起原语挂起后，变为静止就绪状态，表示为 `Readya` ,此时进程不再被调度执行

  - 活动阻塞状态： 进程处于未被挂起的阻塞状态，表示为 `Blockeda` .
  - 静止阻塞状态： 当用挂起原语挂起后，变为静止阻塞状态，表示为 `Blockeds` 。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200718203352.png)

### 进程管理中的数据结构

- **OS中用于管理控制的数据结构**

  在计算机系统中，对于每个资源和每个进程都设置一个数据结构，来表征其实体，称为资源信息表或进程信息表，OS管理的数据结构一般分为以下几类

  - 内存表
  - 设备表
  - 文件表
  - **用于进程管理的进程表**，通常进程表又被称为进程控制块PCB

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719113926.png)

- **PCB的作用**

  使一个在多道环境下不能独立运行的程序（含数据）能独立运行的基本单位，一个能与其它进程并发执行的进程。下面对PCB的具体作用作进一步的阐述：

  - **作为独立运行基本单位的标志**
    - 系统通过PCB感知进程的存在，为其分配所需的资源
  - **能实现间断性运行方式**
    - PCB可以保存中断进程时的CPU现场信息，并在再次调度执行时恢复PCU现场
  - **提供进程管理所需要的信息**
    - 在进程的整个生命周期中，OS总是根据PCB实施对进程的控制和管理
  - **提供进程调度所需要的信息**
    - PCB中提供了进程处于何种状态
  - **实现与其它进程的同步与通信**
    - PCB中设置了用于进程同步的信号量
    - 在PCB中具有实现进程通信的区域

- **PCB中的信息**

  - **进程标识符**
    - :star: 进程标识符用于唯一地标识一个进程
    - 外部标识符
    - 内部标识符
  - **处理机状态**:CPU 线程
  - **进程调度信息**
  - **进程控制信息**

- **PCB的组织方式**

  - 线性方式

    ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719144438.png)

  - 链接方式

    - 即把相同状态进程的PCB分别通过PCB中的链接字链接成一个队列
    - 这样就可以形成就绪队列，阻塞队列，空白队列等

    ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719144824.png)

  - 索引方式

    - 即根据系所有进程状态的不同建立几张索引表

    ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719144933.png)

## 进程控制

进程控制是进程管理中最基本的功能，包括：

- 创建新进程
- 终止已完成的进程
- 将因异常情况而无法继续运行的进程置于阻塞状态
- 负责进程运行中的状态转换

进程控制一般是由OS的内核中的原语来实现的。

进程控制就是要实现进程状态之间的转换

### 操作系统内核

通常将一些与硬件紧密相关的模块（如中断处理程序），各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为OS的内核。

处理机的执行状态分成

- **系统态：** 又称为管态，也称为内核态，它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。
- **用户态： ** 又称为目态，它是具有较低特权的执行状态，仅能执行规定的指令，访问特定的寄存器和存储区，一般情况下，应用程序只能在用户态运行，不能去执行OS指令及访问OS区域。

大多数的**OS内核**包含以下两大方面的功能：

- **支撑功能**
  - **中断处理**
  - **时钟管理**
  - **原语操作**
    - **特点：** 在执行期间不允许中断
- **资源管理功能**
  - 进程管理
  - 存储器管理
  - 设备管理

### 进程的创建

- **创建原语**
  - 申请空白PCB
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列
- **引起进程创建的事件**
  - 用户登录
    - 分时系统中，用户登录成功，系统会为其建立一个新的进程
  - 作业调度
    - 多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
  - 提供服务
    - 用户向OS提出某些请求时，会新建一个进程处理该请求
  - 应用请求
    - 由用户进程主动请求创建一个子进程

### 进程的终止

- **撤销原语**
  - 从PCB集合中找到终止进程的PCB
  - 若进程正在运行，立即剥夺CPU，将CPU分配给其它进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或OS
  - 删除PCB
- **引起进程终止的事件**
  - 正常结束
  - 异常结束
  - 外界干预

### 进程的阻塞

- **阻塞原语**
  - 找到要阻塞的进程对应的PCB
  - 保护进程运行现场，将PCB状态信息设置为”阻塞态“，暂停停止进程运行
  - 将PCB插入相应事件的等待队列
- **引起进程阻塞的事件**
  - 需要等待系统分配某种资源
  - 需要等待相互合作的其它进程完成工作

### 进程的唤醒

- **唤醒原语**
  - 在事件等待队列中找到PCB
  - 将PCB从等待队列移除，设置进程为就绪态
  - 将PCB插入就绪队列，等待被调度
- **引起进程唤醒的事件**
  - 等待事件发生
- 阻塞和唤醒要成对出现

## 进程同步

### 临界资源

**一个时间段内只允许一个进程使用的资源**称为**临界资源**。

对于临界资源的访问，需要互斥的进行。

### 临界区

把每个进程中访问临界资源的那段代码称为临界区

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200720142806.png)

### 同步机制遵循的原则

- 空闲让进
- 忙则等待
- 有限等待
- 让权等待

### 信号量机制

- **整型信号量**

  - 整形信号量定义为一个用于**表示资源数目**的整型量S
  - 一对原语 
    - wait(S)原语，P(S)
    - singal(S)原语，V(S)
  - 

  ```c++
  int S = 1;//初始化整型信号量，表示当前系统中可用打印机的资源数，为1
  void wait(int S){ // wait原语，相当于进入区
      while(S<=0)； //如果资源数不够，就一直循环等待
      S = S - 1;   //如果资源数够了，则占用一个资源 
  }
  
  void signal(int S){ // signal原语，相当于退出区
      S = S + 1; // 使用完资源后，释放资源
  }
  
  /*
  进程P:
  wait(S);
  使用打印机
  signal(S);
  */
  ```

  - **缺点**：在wait操作中，只要是信号量S<=0,就会不断测试，因此该机制未遵循”让权等待“的准则，而是使进程处于”忙等“状态。

- **记录型信号量**

  ```c++
  typedef struct{
      int value; // 它的初值表示系统中某类资源的数目，因而又称为资源信号量
      struct process_control_block *list;
  }semaphore;
  
  void wait(semaphore *S){
      S->value--;//进程请求一个单位的该资源
      if(S->value < 0) block(S->list); 
      //如果小于0，表示该类资源分配完毕，因此进程调用block原语进行自我阻塞，放弃处理机，
      //并插入到信号量链表S->list中
      //此时S->list的绝对值表示给信号量链表中已阻塞进程的数目
  }
  
  void signal(semaphore *S){
      S->value++;//进程释放一个单位资源
      if(S->value <= 0) wakeup(S->list);
      //若加1后仍然是S->vlaue <=0 ,则表示在该信号量链表中仍有等待该资源的进程被阻塞，
      //所以还应该调用wekaup原语，将S->list链表中的第一个等待进程唤醒
      //如果S->value的初始值为1，表示只允许一个进程访问临界资源，
      //此时的信号量转化为互斥信号量，用于进程互斥
  }
  ```

### 信号量的应用

#### 信号量机制实现进程互斥

1. 分析并发进程的关键活动，划定临界区
2. 设置**互斥信号量**mutex，**初值为1**
3. 在临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)

#### 信号量机制实现进程同步

进程同步：要让各并发进程按要求有地推进

1. 设置**同步信号量**S，**初始为0**
2. 在”前操作“之后执行V(S)
3. 在”后操作“之前执行P(S)

#### 信号量机制实现前趋关系

每一对前趋关系都是一个进程同步问题

1. 要为每一对前趋关系各设置一个同步变量
2. 在”前操作“之后对相应的同步变量执行V(S)
3. 在”后操作“之前对相应的同步变量执行P(S)

## 经典进程同步问题

### 生产者-消费者问题

- **问题描述**

  使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

- **问题分析**

  - 缓冲区是一个临界资源，所以需要互斥访问缓冲区，设置一个互斥信号量mutex
  - 消费者不能在空缓冲区中取物品，设置一个同步信号量full，表示消费者需要的满缓冲区的数量
  - 生产者不能在满缓冲区中生生产物品，设置一个同步信号量empty，表示生产者需要的空缓冲区的数量

- **解法**
  - **生产者进程**

  ```
  mutex = 1
  empty = n
  full = 0
  
  producer(){
      while(1){
          生产一个产品；
          P(empty)
          P(mutex)
          把产品放入缓冲区中；
          V(mutex)
          V(full)
      }
  }
  ```

  - **消费者进程**

  ```
  consumer(){
      while(1){
          P(full)
          P(mutex)
          从缓冲区中拿走一个产品；
          V(mutex)
          V(empty)
          消费产品
      }
  }
  ```

### 哲学家进餐问题

- **问题描述**

  五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

  ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200720182614.png)


- **问题分析**

  - 哲学家进餐问题中可以发现，筷子是临界资源，必须互斥的访问
  - 每个哲学家必须占有2个临界资源

- **错误解法**

  - 每个哲学家先拿左边的筷子，再拿右边的筷子

    ```
    semaphore chopstick[5] = {1,1,1,1,1};
    do{
        wait(chopstick[i])
        wait(chopstick[(i+1)%5])；
        吃饭
        signal(chopstick[i]);
        signal(chopstick[(i+1)%5]);
        思考
    }
    ```

  - 如果五位哲学家同时各自拿起左边的筷子时，就会使5个信号量chopstick均为0，导致死锁问题

- **解决方法**

  - 最多只允许4位哲学家同时去拿左边的筷子

  - 仅当哲学家的左，右两只筷子均可用时，才允许他拿起筷子进餐

    ```
    semaphore chopstick[5] = {1,1,1,1,1};
    semaphore mutex = 1
    do{
    	wait(mutex)
        wait(chopstick[i])
        wait(chopstick[(i+1)%5])；
        signal(mutex)
        吃饭
        signal(chopstick[i]);
        signal(chopstick[(i+1)%5]);
        思考
    }
    ```

  - 规定奇数号哲学家先拿左边的筷子，然后拿右边的筷子；而偶数号哲学家则相反

### 读者-写者问题

- **问题描述**

  允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

- **问题分析**

  - 两类进程：写进程，读进程
  - 互斥关系：写进程-写进程，写进程-读进程
  - 写进程和任何进程都是互斥的，设置一个互斥信号量rw

- **解法**

  ```
  semaphore rw = 1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件
  semaphore mutex = 1;//用于保证对count变量的互斥访问
  int count = 0;//记录当前有几个读进程在访问文件
  ```

  - 写者

    ```
    writer(){
        while(1){
            P(rw);
            写文件；
            V(rw);
        }
    }
    ```

  - 读者

    ```
    reader(){
        while(1){
            P(mutex)//各读进程互斥访问count
            if(count == 0){
                P(rw);//第一个读进程负责“加锁”
            }
            count++;
            V(mutex);
            读文件
            P(mutex);
            count--;
            if(count == 0){
                V(rw);//最后一个读进程负责解锁
            }
            V(mutex);
        }
    }
    ```



## 进程通信

**进程通信是指进程间的信息交换**

### 共享存储

进程共享某些数据结构或存储器，进程之间通过这些共享空间进行通信。

- **基于数据结构的共享**
  - 由程序员负责对公共数据结构进行设置
  - 仅适用于传递少量数据，效率低，属于低级通信
- **基于共享存储区的共享**
  - 在内存中划出一个共享存储区，数据的形式和位置以及访问时间都是由进程负责
  - 高级通信

### 管道通信

**管道**是指用于**连接一个读进程和一个写进程以实现它们之间通信的一个共享文件**，又名pipe文件。它是一种半双工通信（对讲机），数据只能**单向流动**，上游进程往管道中写入数据，下游进程从管道中接收数据。如果想实现双方通信，那么需要建立两个管道。

- 当进程在进行读/写操作时，另一个进程必须等待
- 写满才能读，读没才能写
- 确定进行通信的进程双方存在

### 消息传递

将所需要的数据，封装在消息中，利用一个组原语进行通信。

- 直接通信方式
  - 发送进程利用发送原语直接将消息传递给接受进程
- 间接通信方法
  - 进程间的通信由邮箱来完成

### 客户机-服务器

- 套接字
- 远程程序调用
- 远程方法调用

## 线程

### 线程的引入

在没有进程的时候，边听歌，边聊QQ是无法实现的，引入进程后，就可以并发的执行。但有的进程需要同时处理很多事情，比如我想一边视频，一边传送文件，这时就需要引入线程。

**目的**是减少程序在并发执行时所付出的时空开销，增加程序的并发性。

引入线程后，线程就成了程序执行的最小单位。

### 线程与进程的比较

- **调度性**
  - 传统OS中，进程是作为独立运行基本单位，进入线程后，线程是独立运行的基本单位
  - 同一进程下的线程切换，不会引起进程切换
  - 不同进程下的线程切换，会引起进程切换
- **并发性**
  - 引入线程后，不仅进程可以并发执行，同一进程下的所有线程以及不同进程下的线程也都可以并发执行
- **系统开销**
  - 进程开销大于线程开销
- **资源分配**
  - 进程的资源分配的基本单位，进程拥有系统资源，但是进程不拥有系统资源，只包含一些少量的，不可或缺的资源
  - 进程的资源被它下面的所有线程共享

### 多线程OS中的进程属性

- 进程是资源分配的单位
- 进程已不是可执行的实体，线程是独立运行（调度）的基本单位，所谓进程在执行，实际上是进程下的某个线程正在执行。
- 多个线程可并发执行

### 线程的实现方式

- 用户级线程
  - 在用户空间实现
  - 用户级线程与内核无关
- 内核级线程
  - 在内核的支持下运行
  - 每个内核线程都有一个内核控制块，内核利用TCB控制线程
  - **内核级线程才是CPU 的分配单位**
- 组合方法
  - 将用户级线程与内核级线程组合

### 组合方式的三个模型

- 多对一

  - 优点：开销小
  - 缺点：一个线程阻塞，整个进程阻塞

  ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200725161026.png)

- 一对一

  - 优点：并发能力强
  - 缺点：开销大

  ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200725161128.png)

- 多对多

  ![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200725161057.png)