# 0x03 垃圾收集

垃圾回收主要解决以下三个问题：

1. 哪些内存需要回收？
2. 什么时候回收
3. 如何回收？

## 判断对象是否存活

在堆里面存放着Java世界中几乎所有的对象实例， 垃圾收集器在对堆进行回收前， 第一件事情就是要确定这些对象之中哪些还“存活”着， 哪些已经“死去”了。

### 引用计数算法

**算法流程**：

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器值减一；任何时刻计数器为0的对象就是不可能再被使用的。

**缺点**：

难以解决循环引用问题。即 `objA.instance = objB; objB.instance = objA;`，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。

### 可达性分析算法

**基本思路**：

通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。 

![20200717144013.png](https://github.com/yxcoder1997/PictureBed/blob/master/img/20200717144013.png?raw=true)

对象object 5、 object 6、 object 7虽然互有关联， 但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。 

**在Java中，可作为“GC Roots”的对象为：**

- Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中JNI（即通常所说的Native方法）引用的对象
- 方法区中常量引用的对象
- 方法区中类静态属性引用的对象
- Java虚拟机内部的引用
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等 

GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。

## 四种引用类型

在JDK 1.2版之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strongly Re-ference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强
度依次逐渐减弱。

- **强引用：** 是指在程序中最普遍的引用赋值，即`Object obj=new Object()` 。无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。 
- **软引用：** 用来描述一些还有用， 但非必须的对象 。只被软引用关联着的对象， **在系统将要发生内存溢出异常前**， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在JDK 1.2版之后提供了`SoftReference`类来实现软引用。 
- **弱引用：**也是用来描述那些非必须对象， 但是**它的强度比软引用更弱一些**， **被弱引用关联的对象只能生存到下一次垃圾收集发生为止**。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了`WeakReference`类来实现弱引用。 
- **虚引用：** 虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 **一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例**。 **为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。** 在JDK 1.2版之后提供了`PhantomReference`类来实现虚引用。 

## 回收堆中无效对象

- **真正宣告一个对象死亡， 至少要经历两次标记过程** ：
  - 第一次标记：对象在进行可达性分析后发现没有与GC Roots相连接的引用链
  - 第二次标记：判断对象是否有必要执行`finalize()`方法
    - 假如对象没有覆盖`finalize()`方法， 或者`finalize()`方法已经被虚拟机调用过， 那么虚拟机将这两种情况都视为“没有必要执行”。那么对象基本上就会被回收了。
    - 如果这个对象被判定为确有必要执行`finalize()`方法， 那么该对象将会被放置在一个名为`F-Queue`的队列之中， 之后虚拟机会自动建立一条低调度优先级的`Finalizer`线程去执行它们的`finalize()`方法 
  - `finalize()` 方法是对象逃脱死亡的最后一次机会，不过虚拟机不保证等待 `finalize()` 方法执行结束，也就是说，虚拟机只触发 `finalize()` 方法的执行，如果这个方法要执行超久，那么虚拟机并不等待它执行结束，所以最好不要用这个方法。
  - `finalize()` 方法能做的，try-finally 都能做，所以忘了这个方法吧！

## 回收方法区

方法区的垃圾收集主要回收两部分内容：**废弃常量** 和 **无用的类**

- **废弃常量**： 假设再方法区中个字符”abc“,但没有任何引用指向”abc“,这时它就是废弃常量

- **无用的类**

  判定一个类是否是“无用的类”，条件较为苛刻。

  - 该类的所有对象都已经被清除
  - 加载该类的 ClassLoader 已经被回收
  - 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾回收算法

### 分代收集理论

当前商业虚拟机的垃圾回收器，大多数遵循”分代收集“的理论进行设计的，它建立在两个分代假说之上

- **弱分代假说**： 绝大多数对象都是朝生夕灭的
- **强分代假说**： 熬过越多次垃圾收集过程的对象就越难以消亡。

#### 设计原则

这两个分代假说奠定了垃圾收集器的一致的设计原则

- **收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(即熬过垃圾收集过程的次数)分配道不同的区域中存储**

#### 新生代和老年代

设计者一般会把Java堆划分为**新生代**和**老年代**，**在新生代中，每次垃圾收集时会有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代存放**

但分代收集并非只是简单划分一下内存区域那么容易， 它至少存在一个明显的困难： 对象不是孤立的， 对象之间会**存在跨代引用**。 

如果每次都去寻找存活的跨代引用对象，开销将十分大，为了解决这个问题， 就需要对分代收集理论添加第三条经验法则： 

- **跨代引用假说**：跨代引用相对于同代引用来说仅占极少数
  - 某个新生代对象存在跨代引用，但老年代对象难以消亡，这使得新生代得以存活，随着年龄的增长进入老年代，跨代引用也随之消失
  - 在新生代上建立一个全局的数据结构（ 该结构被称为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干小块， 标识出老年代的哪一块内存会存在跨代引用。 此后当发生Minor GC时， 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 

#### 部分名词

- **部分收集**（ Partial GC） ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为：
  - **新生代收集**（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。
  - **老年代收集**（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。
  - **混合收集**（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。
- **整堆收集**（ Full GC） ： 收集整个Java堆和方法区的垃圾收集。 

### 标记-清除算法

- **算法描述**
  - 标记出所有需要回收的对象

  - 标记完成后，统一回收掉所有被标记的对象

    > 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。 标记过程就是对象是否属于垃圾的判定过程

- **缺点**
  - **执行效率不稳定**：标记和清理两个过程的效率都不高
  - **内存空间碎片化**：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719104134.png)

### 标记-复制算法（新生代）

- **目的**
  - 为了解决标记-清除算法面对大量可回收对象时执行效率低的问题 
- **算法流程**
  - 将内存划分为大小相等的两块区域，每次只使用其中的一块
  - 当一块内存用完，就将存活的对象复制到另一块上面，将这一块的内存全部清理掉
- **缺点**： 可用的内存空间减少一半，浪费空间
- **Apple式回收**（优化内存空间）
  - 把新生代划分成
    - 1块较大的Eden空间
    - 2块较小的Survivor空间
  - 每次分配内存只使用Eden区和其中1块Survivor区
  - 回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719111342.png)

### 标记-整理算法（老年代）

- **算法**
  - 移动所有**存活的对象**，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。

这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719112143.png)

## HotSpot的算法细节实现

### 根节点枚举

当使用可达性分析算法判断对象存活，所消耗的时间是巨大的，而且所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，毫无疑问会出现“Stop the World”困扰。

由于目前主流的Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来后，其实并不需要一个不漏检查完所有执行上下文和全局的引用位置， 虚拟机应当是有办法直接得到哪些地方存放着对象引用的。 

- HopSpot是使用一组称为**OopMap**的数据结构来达到这个目的，OopMap记录了栈上本地变量到堆上对象的引用关系

也就是说GC的时候不用遍历整个栈，只遍历每个栈的OopMap就行了。

### 安全点

在OopMap的协助下， HotSpot可以快速准确地完成GC Roots枚举， 但一个很现实的问题随之而来： 可能导致引用关系变化， 或者说导致OopMap内容变化的指令非常多， 如果为每一条指令都生成对应的OopMap， 那将会需要大量的额外存储空间， 这样垃圾收集伴随而来的空间成本十分高昂。

实际上HotSpot也的确没有为每条指令都生成OopMap， 前面已经提到，**只是在“特定的位置”记录了这些信息， 这些位置被称为安全点。**强制要求执行必须到达安全点后才能够暂停。

因此， 安全点的选定既不能太少以至于让收集器等待时间过长， 也不能太过频繁以至于过分增大运行时的内存负荷。 安全点位置的选取基本上是以“**是否具有让程序长时间执行的特征**”为标准进行选定的， 因为每条指令执行的时间都非常短暂， 程序不太可能因为指令流长度太长这样的原因而长时间执行， “长时间执行”的最明显特征就是指令序列的复用， 例如方法调用、 循环跳转、 异常跳转等都属于指令序列复用， 所以只有具有这些功能的指令才会产生安全点。 

对于安全点， 另外一个需要考虑的问题是， 如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程） 都跑到最近的安全点， 然后停顿下来。 这里有两种方案可供选择： 

- 抢先式中断
  - 先把所有用户线程全部中断
  - 如果发现有用户线程的中断地方不在安全点，就恢复这条线程执行，直到安全点
- **主动式中断**（主要使用）
  - 设置一个中断标记
  - 每个线程到达安全点时，检查这个中断标记，选择是否中断自己

### 安全区域

使用安全点的设计似乎已经完美解决如何停顿用户线程， 让虚拟机进入垃圾回收状态的问题了，但实际情况却并不一定。 安全点机制保证了程序执行时， 在不太长的时间内就会遇到可进入垃圾收集过程的安全点。 但是， 程序“不执行”的时候呢？ 所谓的程序不执行就是没有分配处理器时间， 典型的场景便是用户线程处于Sleep状态或者Blocked状态， 这时候线程无法响应虚拟机的中断请求， 不能再走到安全的地方去中断挂起自己， 虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。 对于这种情况， 就必须引入安全区域（Safe Region） 来解决。 

**安全区域是指能够确保在某一段代码片段之中， 引用关系不会发生变化， 因此， 在这个区域中任意地方开始垃圾收集都是安全的。 我们也可以把安全区域看作被扩展拉伸了的安全点。** 

当用户线程执行到安全区域里面的代码时， 首先会标识自己已经进入了安全区域， 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。 当线程要离开安全区域时， 它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段） ， 如果完成了， 那线程就当作没事发生过， 继续执行； 否则它就必须一直等待， 直到收到可以离开安全区域的信号为止。 

## 7个经典垃圾收集器

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200721171104.png)

- 串行收集器：Serial，Serial Old
- 并行收集器：ParNew，Parallel Scavenge，Parallel Old
- 并发收集器：CMS，G1

由于Java的使用场景很多，所以就需要针对不同的场景，提供不同的垃圾回收器。

- **查看垃圾回收器**
  - `-XX:PrintCommandLineFlags`: 查看命令行相关参数（包含使用的垃圾收集器）
  - 使用命令行指令：`jinfo -flag 相关垃圾回收器参数 进程ID`

### Serial与Serial Old收集器：串行回收

Serial收集器作为HotSpot中Client模式下默认的新生代垃圾收集器，采用

- 复制算法
- 串行回收
- “Stop the World”机制方式回收内存

Serial Old收集器作为HotSpot中Client模式下默认的老年代代垃圾收集器，采用

- 整理算法
- 串行回收
- “Stop the World”机制方式回收内存

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200721174449.png)

- **优势**：简单而高效，对于单CPU来说，Serial由于没有线程交互的开销，专心做垃圾收集获得最高单线程收集效率

### ParNew收集器：并行回收

ParNew收集器时Serial的多线程版本

- Par是Parallel缩写，New是只能处理新生代
- 采用并行回收，其它与Serial无区别
- 在 Server 模式下的虚拟机中的首选新生代收集器

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200721175441.png)

### Parallel Scavenge与Parallel Old收集器：吞吐量优先

- Parallel Scavenge目标是达到一个可控制的吞吐量
  $$
  吞吐量 = \frac {运行用户代码时间} {运行用户代码时间+运行垃圾收集时间}
  $$

- 自适应调节策略也是Parallel Scavenge 与 ParNew一个重要区别

- 十分适合于应用在注重吞吐量以及 CPU 资源敏感的场合，因此常在服务器环境中使用

- Parallel Old就是采用整理算法老年代中使用

- JDK 8 是默认的垃圾收集器

### CMS收集器：低延迟

- HotSpot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作
- CMS收集器是一种**以获取最短回收停顿时间为目标**的收集器。**目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上， 这类应用通常都会较为关注服务的响应速度， 希望系统停顿时间尽可能短**， 以给用户带来良好的交互体验。 CMS收集器就非常符合这类应用的需求。  
- CMS收集器是基于标记-清除算法实现的，整体过程分为四个部分
  - **初始标记**
    - 主要任务**仅仅只是标记出GC Roots能直接关联到的对象**
    - 由于直接关联对象比较小，所以这里的速度非常快
  - **并发标记**
    - 从GC Roots的直接关联对象开始遍历整个对象图的过程
    -  这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行 
  - **重新标记**
    - 修正并发标记期间， 因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 
    - 这个阶段的停顿时间通常会比初始标记阶段稍长一些， 但也远比并发标记阶段的时间短 
  - **并发清除**
    - 清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的。 

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200721192606.png)

- **特点**
  - 低停顿
  - 并发收集
    - 由于在垃圾收集阶段用户线程没有中断，所以当堆内存使用率达到一定阈值时，便开始回收
- **弊端**
  - 对CPU资源敏感

    - 占用一部分线程会导致应用程序变慢，吞吐量降低

  - 无法处理浮动垃圾

    - **浮动垃圾**

      在CMS的并发标记和并发清理阶段， 用户线程是还在继续运行的， 程序在运行自然就还会伴随有新的垃圾对象不断产生， 但这一部分垃圾对象是出现在标记过程结束以后， CMS无法在当次收集中处理掉它们， 只好留待下一次垃圾收集时再清理掉。 这一部分垃圾就称为“浮动垃圾”。  

    - 可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。 

  - 基于标记-清除算法，会产生大量碎片
    - 在无法分配大对象的情况下，不得不触发full GC
    - 由于并发执行，为了用户线程能找到对象，不能改变对象地址，不能使用标记整理算法

### G1收集器：区域化分代式

G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。

G1是一个并行回收器，它把堆内存分割为很多不相关的区域Region，哪块Region中存放的垃圾数量最多， 回收收益最大， 这就是G1收集器的Mixed GC模式 

G1是一款面向服务器端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。

![G1 GC内存布局](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200723132829.png)

在上图中，我们注意到还有一些Region标明了H，它代表Humongous，这表示这些Region存储的是巨大对象，即大小大于等于region一半的对象。H-obj有如下几个特征：

* H-obj直接分配到了old gen，防止了反复拷贝移动。 
* H-obj在global concurrent marking阶段的cleanup 和 full GC阶段回收。 
*  在分配H-obj之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC。

为了减少连续H-objs分配对GC的影响，需要把大对象变为普通的对象，建议增大Region size。

- **优势**
  - **并行与并发**
    - 并行性：可以让多个GC线程同时工作，此时用户线程STW
    - 并发性：
  - **分代收集**
    - 从分代上看，G1依然属于分代型垃圾回收器
    - 将堆空间分成若干个Region，这些区域中包含了逻辑上的新生代和老年代
    - 同时兼顾新生代和老年代
  - **空间整合**
    - 内存的回收是以region为基本单位，Region之间是复制算法，从整体上看可以是标记-整理算法
  - **可预测的停顿时间模型**（即软实时 soft real-time）
    - 能明确指定在一个长度为M ms时间片段内，消耗在垃圾收集上的时间不超过N ms
    - 通过将整个Java堆划分成多个大小相等的区域，后台维护一个优先列表，根据统计结果，每次优先回收价值最大的区域
- **回收过程**
  - 初始标记
  - 并发标记
  - 最终标记
  - 筛选回收
- **适用于**
  - 低停顿
  - 不太追求吞吐量

### 总结

|  垃圾收集器  |    分类    |    作用位置    |       使用算法       |     特点     |              适用场景              |
| :----------: | :--------: | :------------: | :------------------: | :----------: | :--------------------------------: |
|    Serial    |    串行    |     新生代     |      标记-复制       | 响应速度优先 |      单CPU环境下的client模式       |
|  Serial Old  |    串行    |     老年代     |      标记-整理       | 响应速度优先 |      单CPU环境下的client模式       |
|    Parnew    |    并行    |     新生代     |      标记-复制       | 响应速度优先 | 多CPU环境Server模式下与CMS配合使用 |
|   Parallel   |    并行    |     新生代     |      标记-复制       |  吞吐量优先  |   后台运算而不需要太多交互的场景   |
| Parallel Old |    并行    |     老年代     |      标记-整理       |  吞吐量优先  |   后台运算而不需要太多交互的场景   |
|     CMS      |    并发    |     老年代     |      标记-清除       | 响应速度优先 |          互联网或B/S业务           |
|      G1      | 并发与并行 | 新生代和老年代 | 标记-整理，标记-复制 | 响应速度优先 |           面向服务端应用           |









