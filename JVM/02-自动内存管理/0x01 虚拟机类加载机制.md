# 0x01 虚拟机类加载机制

## 类加载的时机

一个类型被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期会经历以下7个阶段。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200810125916.png)

其中，验证，准备，解析三个部分统称为连接。

JVM会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。

- **主动引用**
  - 遇到 new、getstatic、putstatic、invokestatic 字节码指令
    - 使用new关键字实例化对象
    - 读取或设置一个类型的静态字段
    - 调用一个类型的静态方法的时候
  - 对类进行反射调用
  - 初始化一个类时，其父类还没有初始化，先触发其父类的初始化
  - 当虚拟机启动时，用户需要指定一个要执行主类（即包含main()方法的那个类），虚拟机初始化这个主类
  - JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic
  - 当一个接口中定义了JDK 8新加入的默认方法（ 被default关键字修饰的接口方法） 时， 如果有这个接口的实现类发生了初始化， 那该接口要在其之前被初始化
- **被动引用**
  - 通过子类引用父类的静态字段，不会导致子类初始化
  - 通过数组定义类引用类，不会触发此类的初始化
  - 常量在编译阶段，会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

## 类的加载过程

### 加载

在加载阶段，java虚拟机需要完成以下三件事情

1. 通过一个类的全限定名来获取定义此类的二进制字节流。 （将.class文件读入内存）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 
3. 在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。 
   - 注意：此时是在方法区中，而不是java堆

### 验证

- **目的**：确保.class文件中的字节流信息符合虚拟机要求，防止虚拟机受到恶意攻击
- **4个验证过程：**
  - **文件格式验证**
    - 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
  - **元数据验证**
    - 对字节码描述的信息进行语义验证
  - **字节码验证**
    - 通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。
  - **符号引用验证**
    - 对类自身以外的信息（常量池中的符号引用）进行匹配性校验

### 准备

- **描述**：为static变量（静态变量）在方法区分配内存，并设置类变量初始值
- **注意**：这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中
- **初始值设定**
  - `public static int value = 123; ` 
    - 变量value在准备阶段过后的初始值为0而不是123，因为此时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器`<clinit>()`方法之中， 所以把value赋值为123的动作要到类的初始化阶段才会被执行。
  - `public static final int value = 123; `
    - 准备后为123，因为被 `static final ` 修饰之后value的值不能被修改，所以在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。 



### 解析



### 初始化

