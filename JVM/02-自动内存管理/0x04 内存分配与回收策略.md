
## 0x04 内存分配与回收策略

[对象优先分配在Eden区](#对象优先分配在Eden区)
[大对象直接进入老年代](#大对象直接进入老年代)
[长期存活对象进入老年代](#长期存活对象进入老年代)
[动态判定对象年龄](#动态判定对象年龄)
[空间分配担保](#空间分配担保)

## 对象优先分配在Eden区

新生对象直接分配到Eden区，如果Eden区没有足够的空间分配时，直接触发一个Minor GC。

虚拟机参数：

- `-Xmx`：Java 堆的最大值；
- `-Xms`：Java 堆的最小值；
- `-Xmn`：新生代大小；
- `-XX:SurvivorRatio=8`：Eden 区 / Survivor 区 = 8 : 1

## 大对象直接进入老年代

大对象就是指需要连续大量内存空间的对象，比如：很长的字符串，元素很多的数组。

- **大对象的判定方式**
    - `-XX:PretenureSizeThreshold`参数：大于该指定设置值的对象直接分配到老年代
        - 该参数只对serial 和 serial old 两个收集器有效 
- **编写程序避免大对象的原因**
    - 存在着那些短命的大对象导致明明有不少空间，却提前触发了GC
    - 大对象的复制开销太大

## 长期存活对象进入老年代

虚拟机给每个对象设置一个对象年龄计数器，存放在对象头中。

对象首先会分配到Eden区，如果在Minor GC中存活下来，就将其复制到Surviver区，并年龄设置为1，之后每次在Surviver区中Minor GC 存活下来后，年龄就加1，直到年龄大于某一个阈值，便进入老年代。

- 利用`-XX:MaxTenuringThreshold`参数设定阈值，默认为 15

## 动态判定对象年龄

如果Surviver区中，同一个年龄的对象大小总和大于Surviver区的一半，年龄大于等于该年龄的对象直接进入老年代，无需等到`-XX:MaxTenuringThreshold`设定的阈值。

## 空间分配担保
