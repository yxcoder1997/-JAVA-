
## 0x04 内存分配与回收策略

- [对象优先分配在Eden区](#对象优先分配在Eden区)
- [大对象直接进入老年代](#大对象直接进入老年代)

- [长期存活对象进入老年代](#长期存活对象进入老年代)

- [动态判定对象年龄](#动态判定对象年龄)

- [空间分配担保](#空间分配担保)


## 对象优先分配在Eden区

新生对象直接分配到Eden区，如果Eden区没有足够的空间分配时，直接触发一个Minor GC。

虚拟机参数：

- `-Xmx`：Java 堆的最大值；
- `-Xms`：Java 堆的最小值；
- `-Xmn`：新生代大小；
- `-XX:SurvivorRatio=8`：Eden 区 / Survivor 区 = 8 : 1

## 大对象直接进入老年代

大对象就是指需要连续大量内存空间的对象，比如：很长的字符串，元素很多的数组。

- **大对象的判定方式**
    - `-XX:PretenureSizeThreshold`参数：大于该指定设置值的对象直接分配到老年代
        - 该参数只对serial 和 serial old 两个收集器有效 
- **编写程序避免大对象的原因**
    - 存在着那些短命的大对象导致明明有不少空间，却提前触发了GC
    - 大对象的复制开销太大

## 长期存活对象进入老年代

虚拟机给每个对象设置一个对象年龄计数器，存放在对象头中。

对象首先会分配到Eden区，如果在Minor GC中存活下来，就将其复制到Surviver区，并年龄设置为1，之后每次在Surviver区中Minor GC 存活下来后，年龄就加1，直到年龄大于某一个阈值，便进入老年代。

- 利用`-XX:MaxTenuringThreshold`参数设定阈值，默认为 15

## 动态判定对象年龄

如果Surviver区中，同一个年龄的对象大小总和大于Surviver区的一半，年龄大于等于该年龄的对象直接进入老年代，无需等到`-XX:MaxTenuringThreshold`设定的阈值。

## 空间分配担保

- 在发生Minor GC之前，先检查老年代最大可用的连续空间是否大于新生代所有对象总空间
  - 如果大于，则说明这次Minor GC 确保安全
  - 如果小于，则先检查虚拟机会查看 `-XX：HandlePromotionFailure` 参数，看看是否允许担保失败
    - 如果允许，老年代最大可用的连续空间是否大于历次新生代晋升老年代对象的平均大小
      - 如果大于，尝试Minor GC，尽管可能是有风险的
      - 如果小于，进行一次Full GC
    - 如果不允许，进行一次Full GC

不过 JDK 6 Update 24 后，`-XX：HandlePromotionFailure` 参数就没有用了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC。

