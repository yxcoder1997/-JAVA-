# 第3章 垃圾收集器与内存分配策略

垃圾回收主要解决以下三个问题：

1. 哪些内存需要回收？
2. 什么时候回收
3. 如何回收？

## 判断对象是否存活

在堆里面存放着Java世界中几乎所有的对象实例， 垃圾收集器在对堆进行回收前， 第一件事情就是要确定这些对象之中哪些还“存活”着， 哪些已经“死去”了。

### 引用计数算法

**算法流程**：

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器值减一；任何时刻计数器为0的对象就是不可能再被使用的。

**缺点**：

难以解决循环引用问题。即 `objA.instance = objB; objB.instance = objA;`，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。

### 可达性分析算法

**基本思路**：

通过一系列称为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。 

![20200717144013.png](https://github.com/yxcoder1997/PictureBed/blob/master/img/20200717144013.png?raw=true)

对象object 5、 object 6、 object 7虽然互有关联， 但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。 

**在Java中，可作为“GC Roots”的对象为：**

- Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中JNI（即通常所说的Native方法）引用的对象
- 方法区中常量引用的对象
- 方法区中类静态属性引用的对象
- Java虚拟机内部的引用
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等 

GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。

## 四种引用类型

在JDK 1.2版之后， Java对引用的概念进行了扩充， 将引用分为强引用（Strongly Re-ference） 、 软引用（Soft Reference） 、 弱引用（Weak Reference） 和虚引用（Phantom Reference） 4种， 这4种引用强
度依次逐渐减弱。

- **强引用：** 是指在程序中最普遍的引用赋值，即`Object obj=new Object()` 。无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。 
- **软引用：** 用来描述一些还有用， 但非必须的对象 。只被软引用关联着的对象， **在系统将要发生内存溢出异常前**， 会把这些对象列进回收范围之中进行第二次回收， 如果这次回收还没有足够的内存，才会抛出内存溢出异常。 在JDK 1.2版之后提供了`SoftReference`类来实现软引用。 
- **弱引用：**也是用来描述那些非必须对象， 但是**它的强度比软引用更弱一些**， **被弱引用关联的对象只能生存到下一次垃圾收集发生为止**。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。 在JDK 1.2版之后提供了`WeakReference`类来实现弱引用。 
- **虚引用：** 虚引用也称为“幽灵引用”或者“幻影引用”， 它是最弱的一种引用关系。 **一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例**。 **为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。** 在JDK 1.2版之后提供了`PhantomReference`类来实现虚引用。 

## 回收堆中无效对象

- **真正宣告一个对象死亡， 至少要经历两次标记过程** ：
  - 第一次标记：对象在进行可达性分析后发现没有与GC Roots相连接的引用链
  - 第二次标记：判断对象是否有必要执行`finalize()`方法
    - 假如对象没有覆盖`finalize()`方法， 或者`finalize()`方法已经被虚拟机调用过， 那么虚拟机将这两种情况都视为“没有必要执行”。那么对象基本上就会被回收了。
    - 如果这个对象被判定为确有必要执行`finalize()`方法， 那么该对象将会被放置在一个名为`F-Queue`的队列之中， 之后虚拟机会自动建立一条低调度优先级的`Finalizer`线程去执行它们的`finalize()`方法 
  - `finalize()` 方法是对象逃脱死亡的最后一次机会，不过虚拟机不保证等待 `finalize()` 方法执行结束，也就是说，虚拟机只触发 `finalize()` 方法的执行，如果这个方法要执行超久，那么虚拟机并不等待它执行结束，所以最好不要用这个方法。
  - `finalize()` 方法能做的，try-finally 都能做，所以忘了这个方法吧！

## 回收方法区

方法区的垃圾收集主要回收两部分内容：**废弃常量** 和 **无用的类**

- **废弃常量**： 假设再方法区中个字符”abc“,但没有任何引用指向”abc“,这时它就是废弃常量

- **无用的类**

  判定一个类是否是“无用的类”，条件较为苛刻。

  - 该类的所有对象都已经被清除
  - 加载该类的 ClassLoader 已经被回收
  - 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾回收算法

### 分代收集理论

当前商业虚拟机的垃圾回收器，大多数遵循”分代收集“的理论进行设计的，它建立在两个分代假说之上

- **弱分代假说**： 绝大多数对象都是朝生夕灭的
- **强分代假说**： 熬过越多次垃圾收集过程的对象就越难以消亡。

#### 设计原则

这两个分代假说奠定了垃圾收集器的一致的设计原则

- **收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(即熬过垃圾收集过程的次数)分配道不同的区域中存储**

#### 新生代和老年代

设计者一般会把Java堆划分为**新生代**和**老年代**，**在新生代中，每次垃圾收集时会有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代存放**

但分代收集并非只是简单划分一下内存区域那么容易， 它至少存在一个明显的困难： 对象不是孤立的， 对象之间会**存在跨代引用**。 

如果每次都去寻找存活的跨代引用对象，开销将十分大，为了解决这个问题， 就需要对分代收集理论添加第三条经验法则： 

- **跨代引用假说**：跨代引用相对于同代引用来说仅占极少数
  - 某个新生代对象存在跨代引用，但老年代对象难以消亡，这使得新生代得以存活，随着年龄的增长进入老年代，跨代引用也随之消失
  - 在新生代上建立一个全局的数据结构（ 该结构被称为“记忆集”， Remembered Set） ， 这个结构把老年代划分成若干小块， 标识出老年代的哪一块内存会存在跨代引用。 此后当发生Minor GC时， 只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 

#### 部分名词

- **部分收集**（ Partial GC） ： 指目标不是完整收集整个Java堆的垃圾收集， 其中又分为：
  - **新生代收集**（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。
  - **老年代收集**（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。
  - **混合收集**（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。
- **整堆收集**（ Full GC） ： 收集整个Java堆和方法区的垃圾收集。 

### 标记-清除算法

- **算法描述**
  - 标记出所有需要回收的对象

  - 标记完成后，统一回收掉所有被标记的对象

    > 也可以反过来， 标记存活的对象， 统一回收所有未被标记的对象。 标记过程就是对象是否属于垃圾的判定过程

- **缺点**
  - **执行效率不稳定**：标记和清理两个过程的效率都不高
  - **内存空间碎片化**：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719104134.png)

### 标记-复制算法（新生代）

- **目的**
  - 为了解决标记-清除算法面对大量可回收对象时执行效率低的问题 
- **算法流程**
  - 将内存划分为大小相等的两块区域，每次只使用其中的一块
  - 当一块内存用完，就将存活的对象复制到另一块上面，将这一块的内存全部清理掉
- **缺点**： 可用的内存空间减少一半，浪费空间
- **Apple式回收**（优化内存空间）
  - 把新生代划分成
    - 1块较大的Eden空间
    - 2块较小的Survivor空间
  - 每次分配内存只使用Eden区和其中1块Survivor区
  - 回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719111342.png)

### 标记-整理算法（老年代）

- **算法**
  - 移动所有**存活的对象**，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。

这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。

![](https://raw.githubusercontent.com/yxcoder1997/PictureBed/master/img/20200719112143.png)